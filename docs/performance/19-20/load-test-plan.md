# 이커머스 서비스 부하 테스트 계획서

> **문서 버전**: v1.0
> **작성일**: 2025-12-22
> **작성자**: Backend/SRE Team
> **검토자**: TBD

---

## 📋 목차

1. [문서 개요](#1-문서-개요)
2. [비즈니스 요구사항 분석](#2-비즈니스-요구사항-분석)
3. [시스템 아키텍처 분석](#3-시스템-아키텍처-분석)
4. [부하 테스트 유형 및 전략](#4-부하-테스트-유형-및-전략)
5. [리스크 및 가설 검증](#5-리스크-및-가설-검증)
6. [사용자 시나리오 설계](#6-사용자-시나리오-설계)
7. [테스트 케이스 정의](#7-테스트-케이스-정의)
8. [성공/실패 기준 정의](#8-성공실패-기준-정의)
9. [테스트 환경 구성](#9-테스트-환경-구성)
10. [실행 계획](#10-실행-계획)
11. [결과 분석 및 개선](#11-결과-분석-및-개선)

---

## 1. 문서 개요

### 1.1 문서 목적

본 문서는 Spring Boot 기반 이커머스 서비스의 **부하 테스트 계획 및 실행 전략**을 정의합니다.

**주요 목적:**
- 실제 사용자 행동 기반 부하 테스트 시나리오 수립
- 주문 생성 API의 트래픽 안정성 검증
- Kafka 기반 선착순 쿠폰 발급 시스템의 피크 트래픽 안정성 검증
- 시스템 병목 지점 식별 및 성능 개선 우선순위 도출

### 1.2 테스트 대상 시스템

**시스템명**: HH Plus 이커머스 플랫폼
**기술 스택**:
- Backend: Spring Boot 3.5.7, Java 17
- Database: MySQL 8.0
- Message Queue: Apache Kafka (KRaft 모드)
- Cache: Redis 7.0
- 인증: X-USER-ID 헤더 기반

**주요 도메인**:
- 상품 조회 및 검색
- 장바구니 관리
- 주문 생성 및 처리
- 쿠폰 발급 (동기/비동기)
- 재고 관리
- 랭킹 조회

### 1.3 테스트 범위 및 제외 사항

**✅ 테스트 범위**:
- 주문 생성 플로우 (상품 조회 → 장바구니 → 주문)
- Kafka 기반 선착순 쿠폰 발급
- 인기 상품 동시 조회 및 주문
- DB 커넥션 풀 안정성
- Kafka Consumer 병렬 처리 성능

**❌ 제외 사항**:
- 외부 결제 게이트웨이 연동 (Mocking 처리)
- 관리자 백오피스 기능
- 배치 작업 (일일 정산, 통계 집계 등)
- CDN 및 정적 리소스 서빙

---

## 2. 비즈니스 요구사항 분석

### 2.1 비즈니스 컨텍스트

**서비스 특성**:
- B2C 이커머스 플랫폼
- 선착순 쿠폰 발급 이벤트 정기 진행
- 플래시 세일 등 피크 트래픽 발생 가능
- 동시 주문 처리 필수

**비즈니스 임팩트**:
- 주문 실패 → 매출 직접 손실
- 쿠폰 발급 실패 → 고객 신뢰도 하락
- 응답 지연 → 전환율 저하 (페이지 로딩 1초 증가 시 전환율 7% 감소)

### 2.2 예상 트래픽 분석

**일반 트래픽 (평시)**:
- DAU (Daily Active Users): 10,000명
- 평균 주문 수: 500건/일
- 평균 TPS: 5~10 req/s
- 피크 시간대 (12:00~13:00, 20:00~22:00): 20~30 req/s

**이벤트 트래픽 (선착순 쿠폰)**:
- 이벤트 시작 직후 5분간 집중
- 예상 동시 접속자: 5,000명
- 예상 TPS: 200~500 req/s (쿠폰 발급 API 기준)

**플래시 세일 트래픽**:
- 특정 상품에 대한 급격한 트래픽 집중
- 예상 동시 주문 시도: 1,000건/분
- 예상 TPS: 50~100 req/s (주문 API 기준)

### 2.3 테스트 목표 및 기대효과

**정량적 목표**:
1. **응답 시간**: P95 < 500ms, P99 < 1000ms
2. **처리량**: 100 TPS 이상 안정적 처리
3. **에러율**: 전체 요청의 1% 미만
4. **시스템 안정성**: CPU < 70%, Memory < 80%, DB Connection Pool 여유 30% 이상

**정성적 목표**:
- 시스템 병목 지점 식별
- 최대 처리 용량 파악
- 장애 발생 시나리오 및 복구 시간 측정
- 성능 개선 우선순위 도출

**기대효과**:
- 서비스 출시 전 안정성 검증
- 인프라 리소스 적정 사이징
- 비용 최적화 (과다/과소 프로비저닝 방지)
- 장애 대응 매뉴얼 수립

---

## 3. 시스템 아키텍처 분석

### 3.1 현재 시스템 구성

```
[Client]
   ↓
[Load Balancer] (가정)
   ↓
[Spring Boot Application] (단일 인스턴스 가정)
   ↓
   ├─→ [MySQL 8.0] (주문, 상품, 재고, 쿠폰 등)
   ├─→ [Redis 7.0] (캐시, 분산락)
   └─→ [Kafka Cluster] (쿠폰 발급 이벤트)
        ↓
      [Consumer Group]
```

**주요 컴포넌트**:
- **API Server**: Spring Boot (단일 인스턴스)
- **Database**: MySQL 8.0 (Persistence Layer)
- **Cache**: Redis 7.0 (상품 캐시, 쿠폰 큐, 분산락)
- **Message Queue**: Kafka (쿠폰 발급 비동기 처리)

### 3.2 주요 병목 지점 식별

**1순위 병목 지점**:

| 병목 지점 | 리스크 | 예상 임팩트 |
|----------|--------|------------|
| **DB 커넥션 풀** | 주문/쿠폰 발급 시 SELECT FOR UPDATE 사용 | 커넥션 고갈 → 전체 API 응답 불가 |
| **Kafka Consumer 처리량** | Consumer 수 < Partition 수 | 쿠폰 발급 지연, 큐 적체 |
| **비관적 락 경합** | 동일 상품 동시 주문 시 락 대기 | 응답 시간 급증, 타임아웃 |

**2순위 병목 지점**:

| 병목 지점 | 리스크 | 예상 임팩트 |
|----------|--------|------------|
| **Redis 연결** | 분산락 사용 증가 | Redis CPU 스파이크 |
| **JVM Heap Memory** | 대량 트래픽 시 GC 빈도 증가 | STW(Stop-The-World) 발생, 응답 지연 |
| **Thread Pool** | Tomcat 기본 Thread Pool 200개 | 요청 큐잉, 타임아웃 |

### 3.3 테스트 대상 선정 근거

**핵심 테스트 대상**:

| API 엔드포인트 | 선정 근거 | 우선순위 |
|---------------|----------|----------|
| **POST /api/orders** | 매출 직결, DB 트랜잭션 복잡도 높음 | ⭐⭐⭐ |
| **POST /api/coupons/issue/kafka** | 피크 트래픽 집중, Kafka 의존성 | ⭐⭐⭐ |
| **GET /api/products/{id}** | 트래픽 가장 높음, 캐시 효과 검증 | ⭐⭐ |
| **POST /api/carts/items** | 주문 전 필수 단계 | ⭐⭐ |
| **GET /api/products/popular** | 이벤트 시 트래픽 집중 | ⭐ |

**선정 기준**:
1. **비즈니스 크리티컬**: 장애 시 매출 손실 또는 고객 경험 저하
2. **기술적 복잡도**: DB 트랜잭션, 분산 시스템 의존성
3. **트래픽 특성**: 피크 트래픽 발생 가능성

---

## 4. 부하 테스트 유형 및 전략

### 4.1 Load Test (기준선 성능 테스트)

**목적**: 정상 트래픽 수준에서 시스템이 안정적으로 동작하는지 검증

**테스트 시나리오**:
- 평시 예상 트래픽 (20~30 TPS)로 30분간 지속
- 일반 사용자 행동 패턴 시뮬레이션

**성공 기준**:
- ✅ 에러율 < 0.1%
- ✅ P95 응답 시간 < 300ms
- ✅ CPU < 50%, Memory < 60%
- ✅ DB 커넥션 풀 사용률 < 50%

**실패 시 조치**:
- 기준선 성능 미달 → 코드 레벨 최적화 필수
- Stress Test 진행 불가 → Load Test 통과 후 재진행

### 4.2 Stress Test (한계점 테스트)

**목적**: 시스템의 최대 처리 용량 및 장애 지점 파악

**테스트 시나리오**:
- 트래픽을 점진적으로 증가 (10 TPS → 200 TPS)
- 시스템이 에러율 5%를 초과하는 지점까지 부하 증가

**성공 기준**:
- ✅ 100 TPS 이상에서 안정적 동작
- ✅ 장애 지점에서 Graceful Degradation (부분 장애, 전체 다운 아님)
- ✅ 부하 감소 시 자동 복구

**검증할 리스크**:
- DB 커넥션 풀 고갈
- JVM Heap Memory 부족
- Kafka Producer 전송 지연
- Thread Pool 고갈

**실패 시 조치**:
- 병목 지점 식별 및 개선
- 인프라 스케일업 또는 스케일아웃 계획

### 4.3 Peak Test (급증 트래픽 테스트)

**목적**: 선착순 이벤트 등 갑작스러운 트래픽 급증 시나리오 검증

**테스트 시나리오**:
- 평시 트래픽 (10 TPS) → 1분 내 500 TPS로 급증 → 5분 유지 → 정상화
- 쿠폰 발급 API에 집중

**성공 기준**:
- ✅ 급증 구간 에러율 < 3%
- ✅ Kafka 메시지 유실 0건
- ✅ 쿠폰 발급 순서 보장 (FIFO)
- ✅ 5분 후 모든 요청 처리 완료

**검증할 리스크**:
- Kafka Producer 버퍼 오버플로우
- Consumer Lag 급증
- Redis 연결 폭증
- Circuit Breaker 오작동

**실패 시 조치**:
- Kafka Partition 증가
- Consumer Concurrency 조정
- Rate Limiting 도입

### 4.4 테스트 유형별 선택 근거 및 우선순위

**선택한 테스트 유형**:
1. ⭐⭐⭐ **Load Test** (필수)
2. ⭐⭐⭐ **Stress Test** (필수)
3. ⭐⭐ **Peak Test** (권장)
4. ❌ **Endurance Test** (제외)

**Endurance Test 제외 근거**:
- 서비스 초기 단계로 24시간 이상 테스트 불필요
- Load Test로 기본 안정성 검증 가능
- 메모리 릭 등은 APM 도구로 모니터링

**실행 순서**:
```
1. Load Test (기준선 확립)
   ↓ Pass
2. Stress Test (한계점 파악)
   ↓ 병목 개선
3. Peak Test (이벤트 대비)
```

---

## 5. 리스크 및 가설 검증

### 5.1 검증 대상 리스크 목록

**Critical 리스크**:

| 리스크 ID | 리스크 내용 | 발생 확률 | 영향도 | 우선순위 |
|----------|------------|----------|--------|---------|
| R-001 | DB 커넥션 풀 고갈 | 높음 | 치명적 | P0 |
| R-002 | Kafka Consumer Lag 급증 | 높음 | 높음 | P0 |
| R-003 | 비관적 락 경합 (재고/쿠폰) | 중간 | 높음 | P1 |
| R-004 | Redis 메모리 부족 | 낮음 | 중간 | P2 |
| R-005 | JVM GC 빈도 증가 | 중간 | 중간 | P2 |

### 5.2 리스크별 가설 및 검증 방법

#### **R-001: DB 커넥션 풀 고갈**

**가설**:
- H1: 주문 API 100 TPS 이상에서 HikariCP 커넥션 풀(기본 10개) 부족
- H2: SELECT FOR UPDATE 락 대기로 인한 커넥션 점유 시간 증가

**검증 방법**:
```sql
-- 모니터링 쿼리
SHOW PROCESSLIST;
SELECT * FROM information_schema.innodb_trx;
```

**측정 메트릭**:
- `hikaricp.connections.active` (Micrometer)
- `hikaricp.connections.pending`
- `hikaricp.connections.timeout.total`

**판정 기준**:
- ✅ Pass: Active Connections < 70% (7/10)
- ❌ Fail: Timeout 발생 또는 Pending > 5

**개선 방안**:
- 커넥션 풀 사이즈 증가 (10 → 20)
- 트랜잭션 범위 최소화
- Read Replica 분리 (조회 쿼리)

---

#### **R-002: Kafka Consumer Lag 급증**

**가설**:
- H1: 쿠폰 발급 요청 500 TPS 시 Consumer 처리 속도(20 req/s) 초과
- H2: Partition 수(10개) < 동시 Consumer 수 → 유휴 Consumer 발생

**검증 방법**:
```bash
# Consumer Lag 모니터링
kafka-consumer-groups.sh --bootstrap-server localhost:9092 \
  --group ecommerce-coupon-consumer-group --describe
```

**측정 메트릭**:
- `kafka.consumer.lag` (Consumer Lag)
- `kafka.consumer.records-consumed-rate`
- `kafka.producer.record-send-rate`

**판정 기준**:
- ✅ Pass: Consumer Lag < 1000 (5분 내 처리 가능)
- ⚠️ Warning: 1000 < Lag < 5000
- ❌ Fail: Lag > 5000 또는 10분 이상 적체

**개선 방안**:
- Partition 증가 (10 → 50)
- Consumer Concurrency 증가 (10 → 20)
- Batch Processing 도입

---

#### **R-003: 비관적 락 경합**

**가설**:
- H1: 동일 상품에 대한 동시 주문 시 SELECT FOR UPDATE 락 대기 발생
- H2: 락 대기 시간이 응답 시간의 70% 이상 차지

**검증 방법**:
```sql
-- 락 대기 상태 확인
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;
```

**측정 메트릭**:
- `spring.data.repository.invocations` (응답 시간)
- DB Slow Query Log
- APM Lock Wait Time

**판정 기준**:
- ✅ Pass: P95 응답 시간 < 500ms
- ❌ Fail: P95 > 1000ms 또는 타임아웃 > 1%

**개선 방안**:
- 낙관적 락 전환 검토
- 재고 차감 로직 개선 (분산락 + 캐시)
- 재시도 로직 추가

---

### 5.3 리스크 우선순위 매트릭스

```
영향도 ↑
높음  │ R-003           R-001, R-002
      │ (락 경합)       (DB/Kafka)
중간  │ R-005           R-004
      │ (JVM GC)        (Redis)
낮음  │
      └─────────────────────────→ 발생 확률
         낮음    중간    높음
```

**우선순위 정의**:
- **P0 (Critical)**: R-001, R-002 → 테스트 전 필수 모니터링 구성
- **P1 (High)**: R-003 → Stress Test에서 집중 검증
- **P2 (Medium)**: R-004, R-005 → 선택적 모니터링

---

## 6. 사용자 시나리오 설계

### 6.1 시나리오 1: 일반 구매 플로우 (Normal Flow)

**목적**: 정상적인 사용자 구매 여정 시뮬레이션

**사용자 여정**:
```
1. 상품 목록 조회 (GET /api/products)
   ↓ (2초 Think Time)
2. 상품 상세 조회 (GET /api/products/{id})
   ↓ (3초 Think Time)
3. 장바구니 추가 (POST /api/carts/items)
   ↓ (5초 Think Time)
4. 주문 생성 (POST /api/orders)
   ↓ (1초 Think Time)
5. 주문 상세 조회 (GET /api/orders/{orderId})
```

**트래픽 특성**:
- 비율: 전체 테스트 트래픽의 70%
- Think Time: 2~5초 (사용자 고민 시간)
- 세션 유지: 5분

**검증 포인트**:
- 전체 플로우 완료율 > 95%
- 주문 생성 성공률 > 99%
- 장바구니 → 주문 전환율 정상 범위

---

### 6.2 시나리오 2: 선착순 쿠폰 발급 경쟁 (Peak Traffic)

**목적**: 이벤트 시작 직후 트래픽 폭증 시나리오

**사용자 여정**:
```
[이벤트 시작 전 30초]
1. 쿠폰 목록 조회 (GET /api/coupons)
   ↓ (대기)

[이벤트 시작 시점 t=0]
2. 쿠폰 발급 요청 (POST /api/coupons/issue/kafka)
   - 5,000명이 동시 요청
   ↓ (폴링 시작)
3. 발급 상태 조회 (GET /api/coupons/issue/status/{requestId})
   - 2초마다 최대 10회 폴링
   ↓
4. 발급 완료 확인 또는 소진
```

**트래픽 모델**:
```
VUs (Virtual Users):
  ┌─────┐
  │     │ 5000 VUs
  │     │
  │     ├─────────┐
  │     │         │ 2000 VUs (폴링)
  └─────┴─────────┴────────→ Time
  0s    5s       60s       120s
```

**트래픽 특성**:
- 초기 급증: 0~5초 (5,000 req)
- 지속: 5~60초 (폴링 2,000 req/s)
- 감소: 60~120초 (정리)

**검증 포인트**:
- Kafka 메시지 유실 0건
- Consumer Lag < 5000
- 중복 발급 0건 (DB UNIQUE 제약 검증)
- 발급 순서 보장 (같은 파티션 내)

---

### 6.3 시나리오 3: 인기 상품 동시 주문 (Spike Traffic)

**목적**: 특정 상품에 대한 동시 주문 시나리오

**사용자 여정**:
```
[플래시 세일 시작]
1. 인기 상품 조회 (GET /api/products/popular)
   ↓ (즉시)
2. 특정 상품 상세 (GET /api/products/1)
   ↓ (1초 Think Time)
3. 즉시 주문 (POST /api/orders)
   - 1,000명이 동일 상품 주문 시도
```

**트래픽 모델**:
```
TPS:
  ┌────┐
  │    │ 100 TPS
  │    │
  │    └────────┐
  │             │ 10 TPS
  └─────────────┴────────→ Time
  0s   60s     120s
```

**검증 포인트**:
- 재고 정합성 (과다 판매 방지)
- 비관적 락 대기 시간 < 500ms
- 재고 소진 시 명확한 에러 메시지
- 주문 실패 시 재고 롤백 정상 동작

---

### 6.4 시나리오별 트래픽 모델

**트래픽 분포 (Load Test 기준)**:

| 시나리오 | 비율 | VUs | 예상 TPS |
|---------|------|-----|---------|
| 일반 구매 플로우 | 70% | 100 | 15~20 |
| 쿠폰 발급 (평시) | 20% | 30 | 5~8 |
| 인기 상품 조회 | 10% | 20 | 3~5 |
| **합계** | 100% | 150 | **25~30** |

**트래픽 분포 (Stress Test 기준)**:

| 시나리오 | 비율 | 최대 VUs | 목표 TPS |
|---------|------|---------|---------|
| 일반 구매 플로우 | 60% | 300 | 60~80 |
| 쿠폰 발급 | 30% | 150 | 30~40 |
| 인기 상품 조회 | 10% | 50 | 10~15 |
| **합계** | 100% | 500 | **100~130** |

---

## 7. 테스트 케이스 정의

### 7.1 Load Test 케이스

**테스트 ID**: LT-001
**테스트명**: 평시 트래픽 안정성 검증

**목표**:
- 평시 예상 트래픽(30 TPS)에서 30분간 안정적 동작 검증

**테스트 구성**:

| 항목 | 값 |
|------|---|
| Virtual Users | 150명 |
| 램프업 시간 | 5분 (0 → 150 VUs) |
| 지속 시간 | 30분 |
| 램프다운 시간 | 2분 |
| Think Time | 2~5초 (사용자별 랜덤) |

**트래픽 패턴**:
```
VUs:
    150 ┌──────────────────────┐
        │                      │
    100 │                      │
        │                      │
     50 │                      │
        │                      │
      0 └──┘                  └──┘
        0  5m               35m 37m
```

**검증 메트릭**:

| 메트릭 | 목표 | 실패 기준 |
|--------|-----|----------|
| 에러율 | < 0.1% | > 1% |
| P95 응답 시간 | < 300ms | > 500ms |
| P99 응답 시간 | < 500ms | > 1000ms |
| Throughput | > 25 TPS | < 20 TPS |
| CPU 사용률 | < 50% | > 70% |
| Memory 사용률 | < 60% | > 80% |
| DB Connection Pool | < 50% | > 80% |

**Pass Criteria**:
- ✅ 모든 메트릭이 목표치 충족
- ✅ 30분간 안정적 처리 (에러 스파이크 없음)
- ✅ 메모리 릭 없음 (Heap 사용량 일정)

---

### 7.2 Stress Test 케이스

**테스트 ID**: ST-001
**테스트명**: 시스템 한계점 파악

**목표**:
- 시스템의 최대 처리 용량 측정
- 장애 발생 지점 및 원인 파악

**테스트 구성**:

| 단계 | VUs | 지속 시간 | 예상 TPS |
|-----|-----|----------|---------|
| 1단계 | 100 | 5분 | 25~30 |
| 2단계 | 200 | 5분 | 50~60 |
| 3단계 | 300 | 5분 | 80~100 |
| 4단계 | 400 | 5분 | 110~130 |
| 5단계 | 500+ | 한계까지 | 150+ |

**트래픽 패턴**:
```
VUs:
    500+┌───┐
    400 │   │
    300 │   │
    200 │   │
    100 │   │
      0 └───┴───────────────┘
        0  5m 10m 15m 20m 25m
```

**검증 메트릭**:

| 메트릭 | 경고 기준 | 장애 기준 |
|--------|----------|----------|
| 에러율 | > 1% | > 5% |
| P95 응답 시간 | > 500ms | > 2000ms |
| Throughput | < 80 TPS | < 50 TPS |
| DB Connection Timeout | > 0 | > 10 |
| Kafka Producer Error | > 0 | > 100 |

**장애 지점 판정**:
- 에러율 5% 초과 시 즉시 중단
- 응답 시간 2000ms 초과 5분 지속
- DB 커넥션 타임아웃 10건 이상

**측정 목표**:
- ✅ 최대 처리 TPS 측정
- ✅ 병목 지점 식별 (DB/Kafka/Thread Pool)
- ✅ Graceful Degradation 여부 확인

---

### 7.3 Peak Test 케이스

**테스트 ID**: PT-001
**테스트명**: 선착순 쿠폰 발급 급증 트래픽

**목표**:
- 이벤트 시작 시 트래픽 급증 시나리오 검증
- Kafka Consumer 처리 성능 검증

**테스트 구성**:

| 단계 | VUs | 지속 시간 | 시나리오 |
|-----|-----|----------|---------|
| 준비 | 1000 | 30초 | 쿠폰 목록 조회 대기 |
| 급증 | 5000 | 5초 | 쿠폰 발급 요청 폭증 |
| 폴링 | 2000 | 55초 | 상태 조회 폴링 |
| 정리 | 500 | 60초 | 나머지 요청 처리 |

**트래픽 패턴**:
```
VUs:
   5000 ┌─┐
   4000 │ │
   3000 │ │
   2000 │ ├─────┐
   1000 ├─┤     │
      0 └─┴─────┴──────┘
        0 30s 35s  90s 150s
```

**검증 메트릭**:

| 메트릭 | 목표 | 실패 기준 |
|--------|-----|----------|
| 쿠폰 발급 성공률 | > 97% | < 90% |
| Kafka 메시지 유실 | 0건 | > 0 |
| Consumer Lag | < 5000 | > 10000 |
| Consumer Lag 해소 시간 | < 5분 | > 10분 |
| 중복 발급 | 0건 | > 0 |
| P95 응답 시간 (발급 API) | < 200ms | > 500ms |

**특수 검증**:
```sql
-- 중복 발급 검증 쿼리
SELECT user_id, coupon_id, COUNT(*) as cnt
FROM user_coupons
WHERE coupon_id = 1
GROUP BY user_id, coupon_id
HAVING cnt > 1;
-- 결과: 0건 (중복 발급 없음)
```

**Pass Criteria**:
- ✅ Kafka 메시지 유실 0건
- ✅ Consumer Lag 5분 내 해소
- ✅ 중복 발급 0건
- ✅ 에러율 < 3%

---

### 7.4 트래픽 램프업 전략

**램프업 (Ramp-up) 전략**:

```javascript
// k6 Stages 구성 예시
export let options = {
  stages: [
    { duration: '5m', target: 100 },  // 램프업: 0 → 100 VUs
    { duration: '30m', target: 100 }, // 유지: 100 VUs
    { duration: '2m', target: 0 },    // 램프다운: 100 → 0 VUs
  ],
};
```

**램프업 설계 원칙**:

1. **점진적 증가**: 갑작스러운 부하 방지
   - Bad: 0 → 1000 VUs (1분)
   - Good: 0 → 100 → 300 → 500 → 1000 VUs (단계별 5분)

2. **Warm-up 시간 확보**:
   - JVM JIT Compilation
   - DB Connection Pool 초기화
   - Cache Warm-up

3. **단계별 검증**:
   - 각 단계에서 메트릭 확인
   - 에러율 1% 초과 시 다음 단계 진입 금지

**램프다운 전략**:
- 급격한 부하 감소로 인한 리소스 해제 검증
- Connection Pool 정리 확인
- 메모리 릭 여부 확인

---

## 8. 성공/실패 기준 정의

### 8.1 핵심 성능 지표 (SLI: Service Level Indicator)

**응답 시간 (Latency)**:

| API | P50 | P95 | P99 | Max |
|-----|-----|-----|-----|-----|
| GET /api/products | 50ms | 150ms | 300ms | 500ms |
| GET /api/products/{id} | 30ms | 100ms | 200ms | 400ms |
| POST /api/orders | 200ms | 500ms | 1000ms | 2000ms |
| POST /api/coupons/issue/kafka | 50ms | 150ms | 300ms | 500ms |

**처리량 (Throughput)**:

| 테스트 유형 | 최소 TPS | 목표 TPS | 우수 TPS |
|------------|---------|---------|---------|
| Load Test | 20 | 30 | 50+ |
| Stress Test | 80 | 100 | 150+ |
| Peak Test | 300 | 500 | 1000+ |

**가용성 (Availability)**:

| 메트릭 | 목표 | 최소 허용 |
|--------|-----|----------|
| 성공률 | > 99.5% | > 99% |
| 에러율 | < 0.5% | < 1% |
| Timeout율 | < 0.1% | < 0.5% |

---

### 8.2 성능 목표 (SLO: Service Level Objective)

**시스템 리소스**:

| 리소스 | 정상 | 경고 | 위험 |
|--------|-----|-----|-----|
| CPU 사용률 | < 50% | 50~70% | > 70% |
| Memory 사용률 | < 60% | 60~80% | > 80% |
| JVM Heap 사용률 | < 70% | 70~85% | > 85% |
| GC Pause Time | < 100ms | 100~500ms | > 500ms |

**데이터베이스**:

| 메트릭 | 정상 | 경고 | 위험 |
|--------|-----|-----|-----|
| Connection Pool Active | < 50% | 50~80% | > 80% |
| Connection Timeout | 0 | 1~10 | > 10 |
| Slow Query (> 1s) | 0 | 1~5 | > 5 |
| Deadlock | 0 | 0 | > 0 |

**Kafka**:

| 메트릭 | 정상 | 경고 | 위험 |
|--------|-----|-----|-----|
| Consumer Lag | < 1000 | 1000~5000 | > 5000 |
| Producer Error | 0 | 1~10 | > 10 |
| Message Loss | 0 | 0 | > 0 |

---

### 8.3 테스트별 Pass/Fail 기준

#### **Load Test (LT-001)**

**Pass 기준**:
- ✅ 에러율 < 0.1%
- ✅ P95 응답 시간 < 300ms
- ✅ 30분간 안정적 처리
- ✅ CPU < 50%, Memory < 60%
- ✅ DB Connection Pool < 50%

**Fail 기준**:
- ❌ 에러율 > 1%
- ❌ P95 응답 시간 > 500ms
- ❌ 메모리 릭 발생 (Heap 증가율 > 10%/10분)
- ❌ DB Connection Timeout 발생

**Warning (재테스트 필요)**:
- ⚠️ 에러율 0.1% ~ 1%
- ⚠️ P95 응답 시간 300ms ~ 500ms

---

#### **Stress Test (ST-001)**

**Pass 기준**:
- ✅ 100 TPS 이상 안정적 처리
- ✅ 장애 지점에서 Graceful Degradation
- ✅ 부하 감소 시 자동 복구

**Fail 기준**:
- ❌ 100 TPS 미만에서 장애 발생
- ❌ 전체 서비스 다운 (모든 API 응답 불가)
- ❌ 부하 감소 후 복구 불가

**측정 목표**:
- 최대 처리 TPS 기록
- 병목 지점 3개 이상 식별
- 개선 우선순위 도출

---

#### **Peak Test (PT-001)**

**Pass 기준**:
- ✅ Kafka 메시지 유실 0건
- ✅ Consumer Lag < 5000
- ✅ Consumer Lag 5분 내 해소
- ✅ 중복 발급 0건
- ✅ 에러율 < 3%

**Fail 기준**:
- ❌ Kafka 메시지 유실 발생
- ❌ Consumer Lag > 10000
- ❌ Consumer Lag 10분 이상 지속
- ❌ 중복 발급 발생
- ❌ 에러율 > 5%

**특수 검증**:
- FIFO 순서 보장 (같은 파티션 내)
- 쿠폰 소진 후 명확한 에러 메시지

---

## 9. 테스트 환경 구성

### 9.1 인프라 구성

**테스트 환경 사양** (운영 환경과 동일 권장):

| 컴포넌트 | 사양 | 비고 |
|---------|-----|-----|
| **Application Server** | 4 vCPU, 8GB RAM | Spring Boot 단일 인스턴스 |
| **MySQL** | 2 vCPU, 4GB RAM | InnoDB Buffer Pool: 2GB |
| **Redis** | 1 vCPU, 2GB RAM | Maxmemory: 1.5GB |
| **Kafka Broker** | 2 vCPU, 4GB RAM | 3대 클러스터 (Replication Factor: 3) |
| **k6 Load Generator** | 4 vCPU, 8GB RAM | 분산 실행 권장 |

**네트워크 구성**:
```
[k6 Load Generator] (격리된 네트워크)
        ↓
[Load Balancer] (가정)
        ↓
[Application Server]
   ├─→ [MySQL]
   ├─→ [Redis]
   └─→ [Kafka Cluster]
```

### 9.2 데이터 준비 전략

**기본 데이터 (Seed Data)**:

| 테이블 | 데이터 수 | 비고 |
|--------|----------|-----|
| users | 10,000명 | userId: 1~10000 |
| products | 1,000개 | 다양한 카테고리 |
| coupons | 10개 | 선착순 쿠폰 포함 |
| inventories | 1,000개 | 재고: 100~1000개 |

**동적 데이터 생성**:
```javascript
// k6에서 동적으로 사용자 ID 생성
const userId = Math.floor(Math.random() * 10000) + 1;
const productId = Math.floor(Math.random() * 1000) + 1;
```

**데이터 정리 전략**:
- 테스트 종료 후 생성된 주문 데이터 삭제
- 재고는 초기 상태로 복구 (Seed Data 재투입)

### 9.3 모니터링 구성

**APM 도구** (권장: Prometheus + Grafana):

**수집 메트릭**:
1. **Application Metrics** (Micrometer):
   - JVM: Heap, GC, Thread
   - HTTP: Request Count, Latency, Error Rate
   - DB: Connection Pool, Query Time

2. **Infrastructure Metrics**:
   - CPU, Memory, Disk I/O
   - Network Throughput

3. **Kafka Metrics**:
   - Producer: Send Rate, Error Rate
   - Consumer: Lag, Records Consumed Rate
   - Broker: Request Rate, Byte Rate

**로그 수집**:
- Application Log (ERROR 레벨)
- Slow Query Log (> 1초)
- Kafka Consumer Lag

**알람 설정**:
| 조건 | 알람 레벨 | 조치 |
|-----|----------|-----|
| 에러율 > 1% | Warning | 모니터링 강화 |
| 에러율 > 5% | Critical | 테스트 중단 |
| CPU > 80% | Warning | 리소스 확인 |
| DB Connection Timeout | Critical | 즉시 조사 |

---

## 10. 실행 계획

### 10.1 테스트 일정

**전체 일정** (2주 소요):

| 활동 | 산출물 |
|-----|-------|
| 테스트 환경 구성 및 검증 | 환경 구성 완료 |
| - 인프라 프로비저닝 | |
| - 모니터링 구성 | |
| - k6 스크립트 작성 | |
| - Dry Run 테스트 | |
| 부하 테스트 실행 | 테스트 결과 리포트 |
| - Load Test | |
| - 결과 분석 및 개선 | |
| - Stress Test | |
| - 결과 분석 및 개선 | |
| - Peak Test | |
| - 최종 결과 정리 | |

### 10.2 실행 순서 및 의존성

**실행 순서**:
```
1. Dry Run (사전 검증)
   ↓ Pass
2. Load Test (기준선 확립)
   ↓ Pass → 병목 개선
3. Stress Test (한계점 파악)
   ↓ 병목 개선
4. Peak Test (이벤트 대비)
   ↓
5. 최종 리포트 작성
```

**의존성 규칙**:
- Load Test 실패 시 Stress Test 진행 불가
- Stress Test 결과 기반으로 Peak Test 트래픽 조정

### 10.3 롤백 계획

**테스트 중단 기준**:
- ✋ 에러율 10% 초과 5분 지속
- ✋ 전체 서비스 다운
- ✋ 데이터 정합성 오류 발생 (중복 주문, 재고 음수 등)

**롤백 절차**:
1. k6 테스트 즉시 중단
2. 애플리케이션 Health Check 확인
3. DB 데이터 정합성 검증
4. 필요 시 DB 롤백 (스냅샷 복구)
5. 원인 분석 후 재시도 계획 수립

---

## 11. 결과 분석 및 개선

### 11.1 결과 분석 기준

**분석 항목**:

1. **성능 메트릭 분석**:
   - 목표 대비 달성률
   - 병목 지점 식별
   - 리소스 사용 패턴

2. **장애 분석**:
   - 에러 유형 분류
   - 근본 원인 파악
   - 재현 가능성 확인

3. **트렌드 분석**:
   - 시간대별 메트릭 변화
   - 단계별 성능 변화
   - 리소스 증가율

### 11.2 이슈 분류 및 우선순위

**이슈 분류 기준**:

| 등급 | 기준 | 예시 |
|-----|-----|-----|
| **P0** | 서비스 장애 | DB 커넥션 풀 고갈 |
| **P1** | 성능 목표 미달 | P95 > 500ms |
| **P2** | 리소스 낭비 | CPU 과다 사용 |
| **P3** | 최적화 여지 | 캐시 히트율 개선 |

### 11.3 성능 개선 계획

**개선 우선순위**:

1. **즉시 개선**:
   - DB Connection Pool 증가
   - Kafka Partition 증가
   - JVM Heap 사이즈 조정

2. **단기 개선**:
   - 쿼리 최적화 (인덱스 추가)
   - 트랜잭션 범위 최소화
   - 캐시 전략 개선

3. **중장기 개선**:
   - Read Replica 도입
   - CQRS 패턴 적용
   - 서비스 분리 (MSA)

**개선 효과 측정**:
- 개선 전후 비교 테스트 수행
- 주요 메트릭 개선률 측정 (Before/After)

---

## 📊 부록: 테스트 체크리스트

### 테스트 실행 전 체크리스트

- [ ] 테스트 환경 Health Check 완료
- [ ] 모니터링 대시보드 정상 동작
- [ ] k6 스크립트 Dry Run 성공
- [ ] 데이터 Seed 완료
- [ ] 롤백 스냅샷 생성
- [ ] 이해관계자 공지 (테스트 시간, 영향 범위)

### 테스트 실행 중 체크리스트

- [ ] 실시간 메트릭 모니터링
- [ ] 에러 로그 확인
- [ ] 리소스 사용률 확인
- [ ] 중단 기준 도달 시 즉시 중단

### 테스트 종료 후 체크리스트

- [ ] 결과 데이터 백업
- [ ] 데이터 정합성 검증
- [ ] 애플리케이션 정상 동작 확인
- [ ] 결과 리포트 작성
- [ ] 개선 계획 수립

